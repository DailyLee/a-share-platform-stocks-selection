# 回测折线图数据处理逻辑总结

## 一、整体流程概述

折线图数据处理分为三个阶段：
1. **数据获取与预处理阶段** (`generateBacktestChart`)
2. **窗口累计数据预计算阶段** (在 `generateBacktestChart` 中)
3. **图表渲染阶段** (`renderChart`)

---

## 二、数据获取与预处理阶段

### 2.1 数据源
- **使用筛选后的历史记录**：`filteredBacktestHistory.value`
  - 如果选择了年度筛选，只使用该年度的数据
  - 如果没有选择年度，使用所有数据

### 2.2 获取完整记录详情
```javascript
// 遍历每条历史记录，获取完整详情（包含大盘收益率）
for (const record of historyToUse) {
  const response = await axios.get(`/platform/api/backtest/history/${record.id}`)
  fullRecords.push(response.data.data)
}
```

### 2.3 按条件分组
- **分组键**：`getConditionKey(config)` = `${stopLoss}_${takeProfit}`
- **分组目的**：将相同止损止盈条件的记录分组，用于生成不同的折线系列

### 2.4 数据合并逻辑
对于每个分组内的记录：
- **时间键**：`timeKey = ${backtestDate}_${statDate}`
- **相同时间的数据处理**：
  - 如果已存在相同 `timeKey` 的数据，跳过当前记录（只保留第一条）
  - 如果不存在，则添加新数据
- **策略**：相同时间的数据只取第一条，不进行合并计算

### 2.5 数据结构构建

#### 2.5.1 回测数据系列
```javascript
seriesDataRate = [
  {
    name: "条件标签（如：-2%/18%）",
    data: [
      {
        date: "2024-01-01",
        value: 5.5,  // 收益率（%）
        investment: 10000  // 投入金额（用于计算累计收益率）
      },
      ...
    ]
  },
  ...
]

seriesDataProfit = [
  {
    name: "条件标签",
    data: [
      {
        date: "2024-01-01",
        value: 550  // 收益金额（元）
      },
      ...
    ]
  },
  ...
]
```

#### 2.5.2 大盘数据
```javascript
marketDataRate = [
  {
    date: "2024-01-01",
    value: 3.2,  // 大盘收益率（%）
    investment: 10000  // 投入金额
  },
  ...
]

marketDataProfit = [
  {
    date: "2024-01-01",
    value: 320  // 大盘收益金额（元）
  },
  ...
]
```

### 2.6 日期收集与排序
- 收集所有回测日期到 `dates` Set
- 排序：`sortedDates = Array.from(dates).sort()`

---

## 三、窗口累计数据预计算阶段

### 3.1 窗口起始位置计算

#### 3.1.1 计算所有可能的窗口起始位置
```javascript
const allWindowStarts = []

if (sortedDates.length <= maxChartItemsPerPage) {
  // 数据量 ≤ 12条，只有一个窗口
  allWindowStarts.push(0)
} else {
  const remainder = sortedDates.length % maxChartItemsPerPage
  if (remainder === 0) {
    // 数据是12的倍数，所有窗口都是12条
    for (let start = 0; start < sortedDates.length; start += maxChartItemsPerPage) {
      allWindowStarts.push(start)
    }
  } else {
    // 数据不是12的倍数
    // 前面的窗口都是12条
    for (let start = 0; start < sortedDates.length - remainder; start += maxChartItemsPerPage) {
      allWindowStarts.push(start)
    }
    // 最后一个窗口从 remainder 位置开始（小于12条）
    const lastWindowStart = sortedDates.length - remainder
    if (!allWindowStarts.includes(lastWindowStart)) {
      allWindowStarts.push(lastWindowStart)
    }
  }
}
```

**示例**：
- 36条数据（12的倍数）：窗口起始位置 = [0, 12, 24]
- 35条数据（不是12的倍数）：窗口起始位置 = [0, 12, 24]（最后一个窗口从24开始，包含11条）
- 37条数据（不是12的倍数）：窗口起始位置 = [0, 12, 24, 36]（最后一个窗口从36开始，包含1条）

### 3.2 累计数据预计算

#### 3.2.1 累计收益率计算逻辑
```javascript
// 对于每个窗口内的数据
let cumulativeProfit = 0      // 累计收益金额
let cumulativeInvestment = 0  // 累计投入金额

// 遍历窗口内的每个日期
windowDates.map(date => {
  const dataPoint = seriesItem.data.find(d => d.date === date)
  if (dataPoint && dataPoint.value !== null && dataPoint.value !== undefined) {
    const investment = dataPoint.investment || 0
    if (investment > 0) {
      cumulativeInvestment += investment
      const profit = (investment * dataPoint.value) / 100
      cumulativeProfit += profit
      // 累计收益率 = 累计收益金额 / 累计投入金额 * 100
      return cumulativeInvestment > 0 ? (cumulativeProfit / cumulativeInvestment) * 100 : 0
    }
    return null
  }
  return null
})
```

**公式**：
- 单期收益金额 = `investment * returnRate / 100`
- 累计收益率 = `(累计收益金额 / 累计投入金额) * 100`

#### 3.2.2 累计收益金额计算逻辑
```javascript
// 对于每个窗口内的数据
let cumulative = 0

windowDates.map(date => {
  const dataPoint = seriesItem.data.find(d => d.date === date)
  if (dataPoint && dataPoint.value !== null && dataPoint.value !== undefined) {
    cumulative += dataPoint.value
    return cumulative
  }
  return null
})
```

**公式**：累计收益金额 = 所有单期收益金额的累加

### 3.3 预计算数据结构
```javascript
precomputedCumulativeData = {
  rate: {
    0: {  // seriesIndex
      0: [累计数据数组],  // windowStart: cumulativeData[]
      12: [累计数据数组],
      ...
    },
    1: { ... },
    ...
  },
  profit: {
    0: { ... },
    ...
  },
  marketRate: {
    0: [累计数据数组],
    12: [累计数据数组],
    ...
  },
  marketProfit: {
    0: [累计数据数组],
    ...
  }
}
```

### 3.4 默认窗口位置设置
```javascript
if (sortedDates.length > maxChartItemsPerPage) {
  const remainder = sortedDates.length % maxChartItemsPerPage
  if (remainder === 0) {
    // 数据是12的倍数，最后一页从倒数第12条开始
    chartWindowStart.value = sortedDates.length - maxChartItemsPerPage
  } else {
    // 数据不是12的倍数，最后一页从倒数第remainder条开始
    chartWindowStart.value = sortedDates.length - remainder
  }
} else {
  chartWindowStart.value = 0
}
```

---

## 四、图表渲染阶段

### 4.1 窗口数据提取
```javascript
const allDates = chartData.value.dates || []
const windowEnd = Math.min(chartWindowStart.value + maxChartItemsPerPage, allDates.length)
const visibleDates = allDates.slice(chartWindowStart.value, windowEnd)
```

### 4.2 单期数据映射
```javascript
// 对于每个系列
const data = visibleDates.map(date => {
  const dataPoint = item.data.find(d => d.date === date)
  return dataPoint ? dataPoint.value : null
})
```

### 4.3 累计数据获取
```javascript
// 优先从预计算数据中获取
if (chartData.value.precomputedCumulativeData) {
  const precomputedData = isRate 
    ? chartData.value.precomputedCumulativeData.rate[index]
    : chartData.value.precomputedCumulativeData.profit[index]
  
  if (precomputedData && precomputedData[chartWindowStart.value]) {
    cumulativeData = precomputedData[chartWindowStart.value]
  }
}

// 如果没有预计算数据，则实时计算（向后兼容）
if (!cumulativeData) {
  // 实时计算逻辑（与预计算逻辑相同）
}
```

### 4.4 图表系列配置

#### 4.4.1 单期数据系列
- **类型**：实线（solid）
- **颜色**：红色系（自选组合）或蓝色（大盘）
- **默认显示**：隐藏（`show: false`）

#### 4.4.2 累计数据系列
- **类型**：虚线（dashed: [10, 5]）
- **颜色**：与单期数据相同
- **默认显示**：显示（`show: true`）

---

## 五、窗口切换逻辑

### 5.1 页码计算

#### 5.1.1 当前页码
```javascript
function getCurrentPage() {
  const remainder = allDates.length % maxChartItemsPerPage
  if (remainder === 0) {
    // 数据是12的倍数，正常计算
    return Math.floor(validStart / maxChartItemsPerPage) + 1
  } else {
    // 数据不是12的倍数，需要特殊处理
    const lastPageStart = allDates.length - remainder
    if (validStart >= lastPageStart) {
      // 当前在最后一页
      return Math.ceil(allDates.length / maxChartItemsPerPage)
    } else {
      // 当前在之前的页面
      return Math.floor(validStart / maxChartItemsPerPage) + 1
    }
  }
}
```

#### 5.1.2 总页数
```javascript
function getTotalPages() {
  return Math.ceil(chartData.value.dates.length / maxChartItemsPerPage)
}
```

### 5.2 窗口切换按钮

#### 5.2.1 上一页按钮
```javascript
@click="chartWindowStart = Math.max(0, chartWindowStart - maxChartItemsPerPage)"
:disabled="getCurrentPage() === 1"
```

#### 5.2.2 下一页按钮
```javascript
@click="chartWindowStart = Math.min(chartData.dates.length - maxChartItemsPerPage, chartWindowStart + maxChartItemsPerPage)"
:disabled="getCurrentPage() >= getTotalPages()"
```

**注意**：模板中使用 `chartData.dates` 是正确的（Vue 自动解包 ref）

### 5.3 窗口变化监听
```javascript
watch(chartWindowStart, () => {
  // 确保窗口位置有效
  // 重新渲染图表（使用预计算的累计数据）
  renderChart()
})
```

---

## 六、发现的问题和潜在错误

### 6.1 数据合并逻辑 ✅

**策略**：相同时间的数据只取第一条，不进行合并计算
```javascript
const existingIndex = mergedDataRate.findIndex(item => item.timeKey === timeKey)
if (existingIndex < 0) {
  // 相同时间的数据，只取第一条
  mergedDataRate.push({
    timeKey,
    backtestDate,
    statDate,
    totalReturnRate: returnRate,
    count: 1
  })
}
```

**优点**：
- 避免数据合并带来的不准确性
- 保持数据的原始性
- 逻辑简单清晰

### 6.2 大盘数据合并 ✅

**策略**：相同日期的数据只取第一条，不进行合并计算
```javascript
const existingIndex = marketDataRate.findIndex(item => item.date === backtestDate)
if (existingIndex < 0) {
  // 相同日期的数据，只取第一条
  marketDataRate.push({
    date: backtestDate,
    value: marketReturnRate,
    investment: totalInvestment
  })
}
```

**优点**：
- 保持数据的原始性
- 避免合并带来的不准确性

### 6.3 投入金额查找逻辑问题 ⚠️

**问题**：在构建 `seriesDataRate` 时，查找投入金额的逻辑可能不准确
```javascript
const investment = profitItem ? 
  (records.find(r => {
    const key = `${r.config.backtest_date}_${r.config.stat_date}`
    return key === item.timeKey
  })?.result?.summary?.totalInvestment || 0) : 0
```

**影响**：
- 如果 `records` 中有多条记录匹配 `timeKey`，只会取第一条的投入金额
- 应该累计所有匹配记录的投入金额

### 6.4 窗口起始位置计算冗余 ⚠️

**问题**：在 `allWindowStarts` 计算中，最后一个窗口的起始位置可能已经包含在前面的循环中
```javascript
for (let start = 0; start < sortedDates.length - remainder; start += maxChartItemsPerPage) {
  allWindowStarts.push(start)
}
const lastWindowStart = sortedDates.length - remainder
if (!allWindowStarts.includes(lastWindowStart)) {
  allWindowStarts.push(lastWindowStart)
}
```

**分析**：
- 如果 `sortedDates.length - remainder` 能被 `maxChartItemsPerPage` 整除，`lastWindowStart` 已经在循环中添加
- 如果 `sortedDates.length - remainder` 不能被 `maxChartItemsPerPage` 整除，`lastWindowStart` 不在循环中
- 例如：35条数据，`remainder = 11`，`lastWindowStart = 24`
  - 循环：`start = 0, 12`，`24` 不在循环中，需要添加 ✓
- 例如：37条数据，`remainder = 1`，`lastWindowStart = 36`
  - 循环：`start = 0, 12, 24`，`36` 不在循环中，需要添加 ✓

**结论**：逻辑是正确的，但可以优化

### 6.5 累计数据计算中的空值处理 ✅

**问题**：如果某个日期没有数据点，返回 `null`
```javascript
if (dataPoint && dataPoint.value !== null && dataPoint.value !== undefined) {
  // 计算累计值
} else {
  return null
}
```

**影响**：图表中会显示断点，这是预期的行为

### 6.6 窗口边界检查 ✅

**问题**：在 `renderChart` 中检查窗口位置是否有效
```javascript
if (chartWindowStart.value < 0) {
  chartWindowStart.value = 0
}
if (chartWindowStart.value >= allDates.length) {
  // 设置为最后一页的起始位置
}
```

**结论**：逻辑正确，确保窗口位置始终有效

---

## 七、优化建议

### 7.1 数据合并优化
- 使用加权平均替代简单平均
- 累计投入金额和收益金额，而不是平均值

### 7.2 性能优化 ✅
- 已实现：预先计算所有窗口的累计数据
- 切换页码时不再重新计算，只从预计算数据中提取

### 7.3 代码优化
- 可以提取窗口起始位置计算逻辑为独立函数
- 可以提取累计数据计算逻辑为独立函数（已部分实现）

### 7.4 错误处理
- 添加数据验证：确保 `investment > 0` 时才计算累计收益率
- 添加边界检查：确保窗口位置不超出数据范围（已实现）

---

## 八、总结

### 8.1 优点 ✅
1. **性能优化**：预先计算所有窗口的累计数据，切换页码时不需要重新计算
2. **窗口逻辑**：正确处理数据不是12倍数的情况，优先保证最新窗口有12条数据
3. **边界检查**：确保窗口位置始终有效
4. **向后兼容**：如果没有预计算数据，可以实时计算

### 8.2 需要改进 ⚠️
1. ~~**数据合并**：使用加权平均替代简单平均~~ ✅ 已改为只取第一条数据
2. **投入金额查找**：当前逻辑已满足需求（只取第一条数据）
3. **代码结构**：提取重复逻辑为独立函数（可选优化）

### 8.3 数据流
```
filteredBacktestHistory
  ↓
获取完整记录详情
  ↓
按条件分组
  ↓
处理相同时间的数据（只取第一条）
  ↓
构建 seriesDataRate、seriesDataProfit、marketDataRate、marketDataProfit
  ↓
计算所有窗口的起始位置
  ↓
预先计算每个窗口的累计数据
  ↓
存储到 chartData.value.precomputedCumulativeData
  ↓
设置默认窗口位置（最后一页）
  ↓
渲染图表（从预计算数据中提取）
```

---

## 九、关键代码位置

- **数据获取**：`generateBacktestChart()` (1820-2192行)
- **窗口计算**：`generateBacktestChart()` 中的 `allWindowStarts` 计算 (2024-2049行)
- **累计数据预计算**：`generateBacktestChart()` 中的 `calculateCumulativeForWindow` (2060-2094行)
- **图表渲染**：`renderChart()` (2217-2630行)
- **页码计算**：`getCurrentPage()` (2658-2682行)、`getTotalPages()` (2685-2691行)
- **窗口切换**：模板中的按钮 (830-856行)

