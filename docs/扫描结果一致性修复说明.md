# 扫描结果一致性修复说明

## 问题描述

在不使用扫描结果缓存的情况下，使用相同的扫描参数，每次扫描结果会有差异。

## 问题原因分析

### 1. 并发处理导致顺序不确定

在 `platform_scanner.py` 中，使用了 `ProcessPoolExecutor` 或 `ThreadPoolExecutor` 来并发获取股票数据。处理结果时使用了 `as_completed()` 方法，这意味着：

- **结果处理的顺序取决于哪个任务先完成**，而不是原始 `stock_list` 的顺序
- 由于网络延迟、API响应时间等因素，每次执行时任务的完成顺序可能不同
- 导致 `platform_stocks` 列表中的股票顺序每次都可能不同

**代码位置**：`api/platform_scanner.py` 第 335-511 行

```python
# 使用 as_completed() 处理并发任务结果
while remaining_futures and processed_count < total_stocks:
    done_futures = [f for f in remaining_futures if f.done()]
    # ... 处理完成的 future，按完成顺序添加到 platform_stocks
    platform_stocks.append(platform_stock)
```

### 2. 行业过滤器依赖输入顺序

`apply_industry_diversity_filter` 函数按照输入列表的顺序遍历股票：

```python
# 第一遍：按顺序选择股票直到达到每个行业的目标数量
for stock in platform_stocks:  # 顺序依赖！
    industry = stock.get('industry', 'Unknown')
    if current_counts[industry] < industry_slots[industry]:
        selected_stocks.append(stock)
        current_counts[industry] += 1
```

**问题**：
- 如果 `platform_stocks` 的顺序不同，即使最终数量相同，选中的股票也可能不同
- 例如：行业A有3只股票，需要选1只。如果顺序是 [股票1, 股票2, 股票3]，会选股票1；如果顺序是 [股票3, 股票1, 股票2]，会选股票3

**代码位置**：`api/industry_filter.py` 第 44-49 行

### 3. Counter.most_common() 在相同值时的顺序不确定

当多个行业有相同数量的股票时，`Counter.most_common()` 的顺序可能不确定：

```python
for i, (industry, _) in enumerate(industry_counts.most_common()):
    industry_slots[industry] = base_per_industry + (1 if i < remainder else 0)
```

虽然 Python 3.7+ 的字典是有序的，但当多个行业有相同计数时，`most_common()` 返回的顺序可能不稳定。

**代码位置**：`api/industry_filter.py` 第 37 行

## 修复方案

### 修复 1：在应用行业过滤器之前对股票进行排序

在 `platform_scanner.py` 中，在应用行业过滤器之前，按股票代码对列表进行排序，确保顺序稳定：

```python
# 按股票代码排序，确保顺序稳定
fundamental_filtered_stocks_sorted = sorted(
    fundamental_filtered_stocks,
    key=lambda s: s.get('code', '')
)
filtered_stocks = apply_industry_diversity_filter(
    fundamental_filtered_stocks_sorted,
    expected_count=config.expected_count
)
```

**修复位置**：`api/platform_scanner.py` 第 741-747 行

### 修复 2：确保行业分配顺序的稳定性

在 `industry_filter.py` 中，对行业进行排序时，先按数量降序，再按行业名称升序，确保顺序稳定：

```python
# 按数量降序，然后按行业名称升序排序，确保顺序稳定
sorted_industries = sorted(
    industry_counts.items(),
    key=lambda x: (-x[1], x[0])  # 数量降序，名称升序
)
for i, (industry, _) in enumerate(sorted_industries):
    industry_slots[industry] = base_per_industry + (1 if i < remainder else 0)
```

**修复位置**：`api/industry_filter.py` 第 35-42 行

## 修复效果

修复后，在相同的扫描参数下：

1. ✅ **股票列表顺序稳定**：按股票代码排序，确保每次扫描时 `platform_stocks` 的顺序一致
2. ✅ **行业分配稳定**：行业分配顺序按数量和名称排序，确保相同情况下顺序一致
3. ✅ **过滤结果一致**：行业过滤器基于稳定的输入顺序，确保每次选中的股票一致

## 测试建议

1. **重复扫描测试**：使用相同的扫描参数，连续执行多次扫描，验证结果是否一致
2. **边界情况测试**：测试多个行业有相同数量股票的情况
3. **并发压力测试**：在高并发情况下验证结果的一致性

## 排序逻辑

修复后，扫描结果会按照以下优先级排序（在行业过滤之后）：

1. **突破确认**（最高优先级）：有突破确认的股票排在前面
2. **突破前兆信号数量**（第二优先级）：突破前兆信号数量多的排在前面
3. **箱体质量**（第三优先级）：箱体质量分数高的排在前面

排序在行业过滤**之后**进行，确保：
- 行业多样性得到保证
- 在相同行业内的股票按突破和箱体质量排序
- 排序结果稳定一致

## 注意事项

- 修复后，扫描结果的顺序可能与之前不同（因为现在是按股票代码排序后再进行行业过滤，最后按突破和箱体质量排序）
- 但相同参数下的扫描结果应该是**完全一致**的
- 排序逻辑确保有突破信号和高质量箱体的股票会排在前面

