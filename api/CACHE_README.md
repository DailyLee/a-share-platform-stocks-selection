# 缓存机制说明

## 概述

为了提高API响应速度，系统实现了基于文件的JSON缓存机制。缓存数据存储在服务器的 `cache/` 目录中，以JSON文件形式保存，支持持久化和跨进程共享。

## 缓存存储位置

- **存储方式**: JSON文件
- **存储目录**: `cache/` (项目根目录下)
- **文件格式**: 每个缓存条目存储为一个独立的JSON文件
- **文件命名**: 使用MD5哈希值作为文件名（如 `a1b2c3d4e5f6...json`）

## 缓存的数据类型

### 1. 股票基本信息 (`fetch_stock_basics`)
- **缓存时间**: 当天有效（数据来自昨天，当天都有效）
- **最小TTL**: 1小时 (3600秒)
- **原因**: 股票基本信息（如股票代码、名称等）变化不频繁，可以缓存较长时间
- **缓存键**: 基于函数名生成

### 2. 行业数据 (`fetch_industry_data`)
- **缓存时间**: 当天有效（数据来自昨天，当天都有效）
- **最小TTL**: 1小时 (3600秒)
- **原因**: 行业分类数据变化不频繁，可以缓存较长时间
- **缓存键**: 基于函数名生成

### 3. K线数据 (`fetch_kline_data`)
- **缓存时间**: 当天有效（数据来自昨天，当天都有效）
- **最小TTL**: 5分钟 (300秒)
- **原因**: K线数据需要保持相对新鲜，但当天都有效
- **缓存键**: 基于股票代码、开始日期、结束日期和重试参数生成

## 缓存工作原理

### 存储机制
1. **文件存储**: 所有缓存数据以JSON格式存储在 `cache/` 目录中
2. **内存缓存**: 同时维护内存缓存作为快速访问层，提升性能
3. **自动持久化**: 数据写入文件后，服务器重启也不会丢失

### 过期机制
1. **基于日期**: 由于数据来自昨天，缓存条目在当天都有效
2. **自动清理**: 过期条目（跨天或超过最小TTL）会在访问时自动删除
3. **最小TTL**: 即使当天有效，也会检查最小TTL确保数据新鲜度

### 工作流程
1. **首次请求**: 
   - 检查内存缓存 → 检查文件缓存 → 从数据源获取 → 保存到文件和内存
2. **缓存命中**: 
   - 内存缓存命中 → 直接返回
   - 文件缓存命中 → 加载到内存 → 返回
3. **自动过期**: 
   - 访问时检查是否过期 → 过期则删除文件和内存条目

## 性能提升

使用缓存后，以下场景会显著提升性能：

1. **重复扫描**: 在短时间内多次执行扫描时，股票基本信息和行业数据会从缓存读取
2. **相同股票查询**: 查询相同股票代码和日期范围的K线数据时，会直接使用缓存
3. **并发请求**: 多个并发请求查询相同数据时，只有第一个请求会访问数据源，其他请求使用缓存
4. **服务器重启**: 缓存数据持久化到文件，重启后仍可使用

## API端点

### 查看缓存统计
```
GET /api/cache/stats
```

返回缓存统计信息，包括：
- `hits`: 缓存命中次数
- `misses`: 缓存未命中次数
- `evictions`: 过期条目清理次数
- `hit_rate`: 缓存命中率（百分比）
- `size`: 当前缓存条目数量（文件缓存）
- `total_requests`: 总请求次数
- `file_reads`: 文件读取次数
- `file_writes`: 文件写入次数
- `memory_cache_size`: 内存缓存条目数
- `file_cache_size`: 文件缓存条目数

### 清除缓存
```
POST /api/cache/clear
```

清除所有缓存条目（包括文件和内存）。用于：
- 强制获取最新数据
- 故障排查
- 测试目的

## 配置

缓存时间可以在 `api/cache_manager.py` 中修改：

```python
CACHE_TTL_STOCK_BASICS = 3600  # 股票基本信息最小缓存时间（秒）
CACHE_TTL_INDUSTRY_DATA = 3600  # 行业数据最小缓存时间（秒）
CACHE_TTL_KLINE_DATA = 300  # K线数据最小缓存时间（秒）
```

**注意**: 虽然设置了最小TTL，但由于数据来自昨天，缓存条目在当天都有效（直到当天结束）。

## 文件结构

缓存文件存储在 `cache/` 目录中，每个文件包含：

```json
{
  "data": {
    // 实际缓存的数据（DataFrame转换为记录列表）
  },
  "created_at": 1234567890.123,
  "expires_at": 1234567890.123,
  "cache_date": "2024-01-15"
}
```

## 注意事项

1. **磁盘空间**: 
   - 缓存文件会占用磁盘空间，但通常不会太大
   - 过期文件会自动清理
   - 可以手动删除 `cache/` 目录来清理所有缓存

2. **数据新鲜度**: 
   - 由于数据来自昨天，缓存在当天都有效
   - 最小TTL确保数据不会过于陈旧
   - 如需最新数据，可以调用 `/api/cache/clear` 清除缓存

3. **并发安全**: 
   - 缓存管理器是线程安全的，可以在多线程/多进程环境中安全使用
   - 文件操作使用锁机制保护

4. **跨进程共享**: 
   - 文件缓存可以在多个进程间共享
   - 内存缓存是进程独立的

5. **服务器重启**: 
   - 文件缓存会保留，重启后仍可使用
   - 内存缓存会丢失，但会从文件重新加载

## 使用示例

缓存是自动启用的，无需额外配置。只需正常调用API即可：

```python
# 第一次调用 - 从数据源获取并缓存到文件
stock_basics = fetch_stock_basics()

# 第二次调用（当天内）- 从文件缓存获取，速度更快
stock_basics = fetch_stock_basics()

# 服务器重启后 - 仍然可以从文件缓存获取
stock_basics = fetch_stock_basics()
```

## 监控建议

建议定期查看缓存统计信息，了解缓存效果：

```bash
curl http://your-server/api/cache/stats
```

如果缓存命中率较低，可能需要：
- 检查缓存时间设置是否合理
- 确认是否有大量不同的查询参数
- 检查 `cache/` 目录中的文件数量
- 考虑调整缓存策略

## 手动管理缓存

### 查看缓存文件
```bash
ls -lh cache/
```

### 清理所有缓存
```bash
rm -rf cache/*
```

### 查看缓存文件内容
```bash
cat cache/<hash>.json
```

## 故障排查

1. **缓存文件损坏**: 系统会自动检测并删除损坏的文件
2. **磁盘空间不足**: 需要手动清理 `cache/` 目录
3. **权限问题**: 确保应用有读写 `cache/` 目录的权限
4. **文件锁定**: 多进程访问时，系统使用锁机制避免冲突
